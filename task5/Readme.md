# EventBooker — Сервис бронирования мероприятий с дедлайнами

Сервис для управления бронированием мест на мероприятиях с автоматической отменой неоплаченных бронирований по истечении заданного времени.

## Особенности

- Создание мероприятий с ограниченным количеством мест
- Бронирование мест с временным ограничением
- Подтверждение бронирований (оплата)
- Автоматическая отмена неоплаченных бронирований
- Веб-интерфейс для пользователей и организаторов
- JWT-аутентификация
- Поддержка нескольких пользователей с разными ролями

## Быстрый старт

### 1. Клонирование и запуск

```bash
git clone <repository-url>
cd eventbooker
make rebuild
```

Сервис будет доступен по адресу: http://localhost:8080

### 2. Настройка

Создайте `.env` файл на основе `.env.example`:

### 3. Docker Compose

Основные сервисы в `docker-compose.yml`:
- eventbooker: основное приложение (Go)
- postgres: база данных
Подключение переменных берётся из файла .env

## API Endpoints

### Аутентификация
```bash
# Регистрация пользователя
POST /register
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "password123",
  "name": "John Doe",
  "phone": "+1234567890"
}

# Вход пользователя
POST /login
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "password123"
}
```

### Мероприятия
```bash
# Получить все мероприятия
GET /events

# Получить информацию о мероприятии
GET /events/{id}

# Создать мероприятие (требует аутентификации)
# Пользователь не может зарегистрироваться на собственное мероприятие, так что советую создать админа, который создаёт мероприятия и пару пользователей для бронирования)
POST /events
Content-Type: application/json
Authorization: Bearer <token>

{
  "name": "Концерт",
  "date": "2024-01-01T19:00:00Z",
  "cost": 1000,
  "total_seats": 100,
  "life_span": "15m"
}
# Для проверки отмены бронирования советую ставить "life_span": "1m", тогда бронирование будет быстро отменяться
```

### Бронирования
```bash
# Забронировать место (требует аутентификации)(будет возвращён booking_code, который нужно сохранить)
POST /events/{id}/book
Content-Type: application/json
Authorization: Bearer <token>

{
  "seat_count": 2
}

# Подтвердить бронирование (требует аутентификации)
POST /events/{id}/confirm
Content-Type: application/json
Authorization: Bearer <token>

{
  "booking_code": "ABC123"
}
```

## Примеры использования

### Создание мероприятия
```bash
# Убедитесь, что дата находится в будущем
curl -X POST http://localhost:8080/events \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <token>" \
  -d '{
    "name": "Мастер-класс по программированию",
    "date": "2024-01-15T14:00:00Z",
    "cost": 500,
    "total_seats": 30,
    "life_span": "30m"
  }'
```

### Бронирование места
```bash
curl -X POST http://localhost:8080/events/1/book \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <token>" \
  -d '{"seat_count": 2}'
```

### Подтверждение бронирования
```bash
# параметр cost не влияет на подтверждение, нужен только booking_code
curl -X POST http://localhost:8080/events/1/confirm \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <token>" \
  -d '{"booking_code": "BOOKING123"}'
```

## Веб-интерфейс

После запуска сервиса откройте http://localhost:8080 в браузере для доступа к веб-интерфейсу.

Возможности веб-интерфейса:
- Регистрация и аутентификация пользователей
- Просмотр доступных мероприятий
- Бронирование мест на мероприятиях
- Подтверждение бронирований
- Создание мероприятий (для организаторов)
- Просмотр статистики бронирований

## Статусы бронирований

- `pending`: бронирование создано, ожидает подтверждения
- `confirmed`: бронирование подтверждено (оплачено)
- `cancelled`: бронирование отменено вручную
- `expired`: бронирование автоматически отменено по истечении времени
Их лучше посмотреть в sql таблицах через `make sql_connect` и `select * from bookings;`
## Настройка времени бронирования

Время жизни бронирования настраивается для каждого мероприятия отдельно:
- `15m`: 15 минут
- `1h`: 1 час
- `2h`: 2 часа
- и т.д.

## Безопасность

- JWT-аутентификация
- Валидация входных данных
- Защита от SQL-инъекций
- CORS-политика

## Фоновые процессы

Сервис включает фоновый обработчик, который:
- Автоматически отменяет неоплаченные бронирования по истечении времени(указанного в событии)
- Освобождает места для других пользователей(срок истечения jwt-токена)
- Работает на основе cron-расписания

## Поддержка

При возникновении проблем:

1. **Проверьте логи приложения**:
   ```bash
   make logs
   ```

2. **Убедитесь, что все сервисы запущены**:
   ```bash
   docker compose ps
   ```

3. **Проверьте подключение к базе данных**:
   ```bash
   make sql_connect
   ```

## Структура проекта

- `internal/models`: модели данных и структуры
- `internal/service`: бизнес-логика приложения
- `internal/server`: HTTP-обработчики и маршрутизация
- `internal/frontend`: веб-интерфейс
- `pkg/config`: конфигурация приложения
- `pkg/logger`: логирование

## Производительность

- Асинхронная обработка фоновых задач
- Оптимизированные запросы к базе данных
- Кэширование часто запрашиваемых данных
- Поддержка транзакций для избежания гонок данных

---

**Примечание**: Бронирования автоматически отменяются по истечении заданного времени. Пользователи получают уникальный код бронирования для подтверждения.

**Примечание**: Организаторы могут создавать мероприятия с различными параметрами, включая настраиваемое время жизни бронирований.


---
P.S. Я постарался реализовать в этом проекте JWT-аутентификацию и правильное логирование на всех слоях (в мейне можно выбирать, какой слой будет показывать логи, а какой нет), приблизился к пониманию DI и постараюсь реализовать его в следующем проекте. Но если честно очень душит фронтенд, обычно чуть больше дня уходит просто на то, чтобы написать его нейронкой, а затем чинить и подключать к сервису. Реализовывать возможность создания нескольких пользователей тоже было интересно, но написать нормальные и полностью автоматизированные тесты не получилось, что мне очень не нравится. Уведомления через тг у меня получилось реализовать в первом(или втором проекте), так что сейчас я не вижу в этом смысла.
